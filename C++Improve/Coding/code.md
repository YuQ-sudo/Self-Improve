# Concept

## 双指针

* 双指针主要作用是减少循环次数，降低时间复杂度。一般使用方式是一个快指针一个慢指针进行偏移。注意快慢指针的循环以及开始结束的时间点
* 主要用于数组、链表、字符串、求和等操作。
* 常见考题反转链表、删除数组特定值等。
  
## 栈与队列

* 队列是先进先出，栈是先进后出
* 栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现
  
## 回溯算法

* 回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质
* 回溯法抽象为树形结构后，其遍历过程就是：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。
  
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 贪心算法

* 局部最优--->全局最优

## 动态规划

* 解题步骤
  * 确定dp数组（dp table）以及下标的含义
  * 确定递推公式
  * dp数组如何初始化
  * 确定遍历顺序
  * 举例推导dp数组
* 背包问题
  * 问题描述：01背包 n件物品和一个能装重量w的背包。第i件物品重量为w[i] 价值为value[i]
  * 确定dp数组初始化
  * 确定循环次序
  * 问题描述：完全背包问题 可重复填充
  * 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
  * 如果求排列数就是外层for遍历背包，内层for循环遍历物品。


<!-- Leetcode岛屿问题专项 -->

<!-- ## https://zhuanlan.zhihu.com/p/480696645 -->

* 岛屿衍生问题主要有岛屿数量 岛屿周长 岛屿最大面积等问题
* 解决方法：DFS。base case 以及 相邻节点访问。
* 以方格（r,c）相邻网格（r-1,c）（r+1,c）（r,c-1）（r,c+1）进行搜索。
* 需要注意的是 避免重复遍历。否则会进入死循环。
  
```cpp
void dfs(vector<vector<char>>&grid,int r,int c){
        //base case
        //如果坐标越界直接返回,是海洋返回，访问过了返回
        if(!inArea(grid,r,c)||grid[r][c]!='1'){
            return;
        }
        grid[r][c]='2';
        dfs(grid,r-1,c);
        dfs(grid,r+1,c);
        dfs(grid,r,c-1);
        dfs(grid,r,c+1);
    }
    bool inArea(vector<vector<char>>&grid,int r,int c){
        return 0<=r&&r<grid.size()&&0<=c&&c<grid[0].size();
    }

```
## 每日刷题打卡

### 20230321

* [x] 反转字符串 交换函数优化点：节省空间，使用位与操作
  
1. 在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志
2. 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束

```cpp
    s[i] ^= s[j];
    s[j] ^= s[i];
    s[i] ^= s[j];
```

* [x] 15.三数求和  如何去重
* [x] 142.链表求环 快慢指针如何进行循环(如何判定结束)
  
### 20230322

* [x] 225.队列实现栈功能
* [x] 239.maxSlidingWindow 滑窗取最大值(关键:维护的队列要保持单调)

### 20230327

* [ ] 77.组合回溯算法 for循环横向遍历 递归纵向遍历。画好N×图帮助理解回溯过程。优化过程 一般是剪枝操作。

### 20230328

* [x] 216.组合求和问题。类似于77解法。
* [ ] 17.电话字符串组合。关键在于回溯的深度索引。

### 20230329

* [ ] 131.分割回文子串.关键：回溯方式+回文子串判断
* [ ] 455.分发饼干

### 20230330

* 贪心算法 局部最优找全局最优 基本可以归纳为极值推最值问题
* [ ] 376.摆动序列
* [ ] 53.最大连续子数组和
* [ ] 122.股票最佳时机 ，其实我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间
* [ ] 55.跳跃游戏 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点

### 20230331

* [ ] 45.跳跃游戏2 需要注意再次复习

### 20230402

* [x] 1005.K次取反后最大化的数组和：比较简单 注意排序方式
* [x] 134.加油车站 暴力方法超时，思想是局部内不满足 直接更新index
* [x] 135.分发糖果 题目很巧妙，需要再次复习
  * 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
  * 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。
  * 这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果。
* [x] 860.柠檬水找零

### 20230403

* [x] 406.根据身高重建队列

### 20230406

* [x] 452.用最少数量的箭引爆气球
* [x] 435.无重叠区间
* [x] 56.合并区间
* [ ] 343.拆分整数 有点意思 需要复习下

### 20230407

* [ ] 96.不同的二叉搜索树。有点东西 需要复习下。状态转移方程的推导过程。
* [ ] 416.分割等和子集
* [ ] 1049.石头最小

### 20230410

* [ ] 518.零钱兑换 不需要排列顺序。因此直接进行使用dp[j] += dp[j -nums[i]] 先遍历物品，再遍历背包即可。
* [ ] 377.组合总和 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数；回溯算法存在超时，动态规划需要注意，顺序不同 组合不同。因此需要先遍历背包，再遍历物品。
* [ ] 70.爬楼梯 衍生出完全背包问题。
* [ ] 322.零钱兑换最小数。
* [ ] 279.完全平方数。
  
### 20230411

* [ ] 股票问题。

### 20230414

* [ ] 300.最大递增子序列
* [ ] 674.最大连续递增子序列


### 排序

